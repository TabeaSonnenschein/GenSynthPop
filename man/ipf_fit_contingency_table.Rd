% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iterative_proportionate_fitting.R
\name{ipf_fit_contingency_table}
\alias{ipf_fit_contingency_table}
\title{Iterative Proportional Fitting (IPF) for Contingency Tables}
\usage{
ipf_fit_contingency_table(
  df_contingency,
  group_name,
  group_by,
  margins = NULL,
  margins_names = NULL,
  marginorder = NULL,
  uncoveredcontingency = NULL
)
}
\arguments{
\item{df_contingency}{A data frame representing the contingency table, with one column for each variable and a \code{count} column.}

\item{group_name}{A vector of values corresponding to the group to filter (the subset defined by \code{group_by}).}

\item{group_by}{A character vector of column names used to filter the contingency table for the given \code{group_name}.}

\item{margins}{A list of data frames containing marginal distributions (e.g., age, sex) for IPF.
Each data frame must contain a column for the margin values and a \code{count} column.}

\item{margins_names}{A list of column names corresponding to the margins, i.e., the names of the variables for which
marginal distributions are provided.}

\item{marginorder}{A list of vectors, where each vector contains the levels (order) of the corresponding margin variable.
The order of each margin will be used when transforming the contingency table to a multi-dimensional array.}

\item{uncoveredcontingency}{A list of column names for variables in the contingency table that do not have
associated marginal distributions. These will be incorporated into the multi-dimensional array for IPF but are not constrained by margins.}
}
\value{
A data frame of the fitted contingency table, where the counts have been adjusted to match the provided margins.
The resulting data frame will include all the original variables along with the adjusted \code{count} column.
}
\description{
This function performs iterative proportional fitting (IPF) on a contingency table to adjust the table's counts to match
specified marginal distributions. If no margins are provided, it simply returns the relevant subset of the table.
The function supports multi-dimensional contingency tables and handles cases where some margins are uncovered.
}
\details{
If \code{margins} is provided, the function performs IPF on the contingency table to fit the table to the specified marginal distributions.
If no margins are provided (\code{margins = NULL}), it returns the subset of the table based on the values of \code{group_name} and \code{group_by}.
The function first transforms the contingency table into a multi-dimensional array, fits the table using IPF, and
then transforms the adjusted array back into a data frame.

The uncovered contingency variables (\code{uncoveredcontingency}) are included in the fitting process but not constrained by
the marginal distributions.
}
\note{
This function relies on the \code{Ipfp} function from the \code{mipfp} package for the iterative proportional fitting procedure.
If marginal totals are inconsistent, IPF shifts to probabilities to correct them. A custom handler is used to suppress
specific warnings related to this adjustment.
}
\examples{
# Example usage:
df_contingency <- data.frame(
  age_group = c("0-15", "15-25", "25-45", "45-65", "65+"),
  sex = c("male", "female", "male", "female", "male"),
  migrationbackground = c("Dutch", "Dutch", "Non-Dutch", "Dutch", "Non-Dutch"),
  count = c(19, 31, 66, 54, 29)
)

margins <- list(
  age_group = data.frame(
    neighb_code = c("neigh_123", "neigh_123", "neigh_123", "neigh_123", 
               "neigh_123", "neigh_456", "neigh_456", "neigh_456", "neigh_456", "neigh_456"),
    age_group = c("0-15", "15-25", "25-45", "45-65", "65+", "0-15", 
                 "15-25", "25-45", "45-65", "65+"),
    count = c(50, 100, 150, 200, 75, 40, 90, 130, 180, 60)
  ),
  sex = data.frame(
    neighb_code = c("neigh_123", "neigh_123", "neigh_456", "neigh_456"),
    sex = c("male", "female", "male", "female"),
    count = c(250, 200, 220, 180)
  )
)

fitted_table <- ipf_fit_contingency_table(
  df_contingency, 
  group_name = "neigh_123",  # Neighborhood code for filtering
  group_by = c("neighb_code"),  # Column representing the neighborhood grouping
  margins = margins,
  margins_names = c("age_group", "sex"),
  marginorder = list(c("0-15", "15-25", "25-45", "45-65", "65+"), c("male", "female")),
  uncoveredcontingency = c('migrationbackground')
)

print(fitted_table)

}
\seealso{
\code{\link[mipfp]{Ipfp}} for the core IPF algorithm.
}
