% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/validating_distribution.R
\name{crossvalid}
\alias{crossvalid}
\title{Cross validation with the neighborhood and stratified marginal distributions}
\usage{
crossvalid(
  valid_df,
  agent_df,
  join_var,
  list_valid_var,
  agent_var,
  list_agent_attr
)
}
\arguments{
\item{valid_df}{the dataset that contains the marginal distributions, this can be the neighborhood totals dataset or the stratified dataset}

\item{agent_df}{is the agent dataset, which now contains the newly generated variable}

\item{join_var}{is the variable or variables on which basis the datasets should be joined/ compared. For a neighborhood totals dataset this would be the neighborhood code, while for a stratified dataset this would be all the conditional variables.}

\item{list_valid_var}{lists the variables in the valid_df that should be compared to the newly generated variable.(e.g when having generated the variable sex, then the variables we want to compare would be perhaps c("men", "women", "non_binary"))}

\item{agent_var}{states the newly generated variable in the agent_df that should be validated}

\item{list_agent_attr}{lists the generated attributes of this agent_var (e.g. c("male", "female", "non_binary")). Attention: the order of the list_valid_var and list_agent_attr needs to be equal.}
}
\value{
orginal distribution dataset, agent distribution and difference
}
\description{
This function generates a table for validation that compares the original marginal distributions to the generated distributions of the agent dataset. valid_df is the dataset that contains the marginal distributions, this can be the neighborhood totals dataset or the stratified dataset; agent_df is the agent dataset, which now contains the newly generated variable join_var is the variable or variables on which basis the datasets should be joined/ compared. For a neighborhood totals dataset this would be the neighborhood code, while for a stratified dataset this would be all the conditional variables. list_valid_var lists the variables in the valid_df that should be compared to the newly generated variable. (e.g when having generated the variable sex, then the variables we want to compare would be perhaps c("men", "women", "non_binary")). agent_var states the newly generated variable in the agent_df that should be validated list_agent_attr lists the generated attributes of this agent_var (e.g. c("male", "female", "non_binary")).    Attention: the order of the list_valid_var and list_agent_attr needs to be equal.
}
\examples{
## generating some example mock data (based on random numbers)
### stratified dataframe mock data ###
age_group = c("A1", "A2", "A3", "A4", "A1", "A2", "A3", "A4", "A1", "A2", "A3", "A4")
sex = c("male","male","male","male", "female","female","female","female", "non-binary", "non-binary", "non-binary","non-binary")
employed = sample(1:400,length(age_group))
unemployed = sample(1:400,length(age_group))
total_pop = employed + unemployed
stratified_df = data.frame(age_group, sex , employed, unemployed, total_pop)

### agent dataframe mock data ###
# This should be the actual agent_df that is the output of one of the attribute distribution algorithms
agent_df = as.data.frame(paste("Agent_",1:500, sep=""))
agent_df$neigh_ID = sample(1:10, size =nrow(agent_df), replace = T)
agent_df$age_group = age_group[sample(1:length(age_group), size = nrow(agent_df), replace = T)]
agent_df$sex = sex[sample(1:length(age_group), size = nrow(agent_df), replace = T)]
agent_df$employ_status = c("employed","unemployed")[sample(1:2, size = nrow(agent_df), replace = T)]
colnames(agent_df) = c("agent_id", "neigh_ID", "age_group", "sex", "employ_status")
print(agent_df)

### neighborhood totals dataframe ###
# since agents have been generated to represent the number of people in a previous step,
# here the neighborhood totals have to be equal to the count of the number of agents in the neighborhood
# if it is not exactly equal that is fine, the algorithm can handle that (it is common that in census data the population totals can vary depending on the variable)
neigh_df = as.data.frame(1:10)
colnames(neigh_df) = c("neigh_ID")
neigh_df$total = NA
neigh_df$employed = NA
for(id in neigh_df$neigh_ID){
   neigh_df$total[id] = length(which(agent_df$neigh_ID == id))
   neigh_df$employed[id] = sample(1:neigh_df$total[id], size = 1)
}
neigh_df$unemployed = neigh_df$total - neigh_df$employed
print(neigh_df)


# function application on neighborhood distribution dataframe
neigh_valid = crossvalid(valid_df = neigh_df, agent_df = agent_df, join_var = "neigh_ID", list_valid_var = c("employed", "unemployed"), agent_var = "employ_status", list_agent_attr = c("employed", "unemployed"))
print(neigh_valid)

# function application on stratified dataframe
strat_valid = crossvalid(valid_df = stratified_df, agent_df = agent_df, join_var = c("age_group", "sex"), list_valid_var = c("employed", "unemployed"), agent_var = "employ_status", list_agent_attr = c("employed", "unemployed"))
print(strat_valid)

# Since these examples are based on random distributions, there is no correspondence between the agent_df distribution and the neigh_df/stratified_df distribution
# However, when following the methods, it should correspond

}
